package Groceries;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.HttpStatusCode;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.server.ResponseStatusException;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.DeleteMapping;

import org.springframework.web.bind.annotation.RequestBody;

@Controller // Means that the class is a controller
@RequestMapping(path="/api") // Means URL's start with /grocery (after application path)
public class GroceryController {
    @Autowired // Means to get the bean called groceryRepository, which is auto-generated by Spring
    private GroceryRepository groceryRepository;

    // @ResponseBody means the returned String is the response, not a view name
    // @RequestParam means that it is a parameter from the GET or POST request
    // (queryparam + formdata + multipart all get combined into "parameters")
    @PostMapping("/groceries") // Map ONLY POST Requests
    public @ResponseBody Grocery addNewGrocery(@RequestParam String itemName, @RequestParam Integer amount) {

        Grocery grocery = new Grocery(itemName, amount);
        System.out.println("Saving new data - " + grocery.toString());
        groceryRepository.save(grocery);
        return grocery;
    }

    
    @GetMapping("/groceries")
    public @ResponseBody Iterable<Grocery> getAllGroceries() {
        // this returns a JSON or XML with all the groceries
        return groceryRepository.findAll();
    }

    // Type mismatch: cannot convert from Optional<Grocery> to GroceryJava(16777235)
    // this is before .orElseGet was included.
    // because findById returns Optional<T> - have to cover for Optional
    @GetMapping("/groceries/{id}")
    public @ResponseBody Grocery getOneGrocery(@PathVariable Integer id) {
        return groceryRepository.findById(id)
        .orElseThrow(() -> new ResponseStatusException(HttpStatus.NOT_FOUND, "Grocery not found with id: " + id));
    }


    // tried to use @RequestParam String itemName, @RequestParam Integer amount, like in POST, but didn't work
    // my POST in JavaScript uses formData. @RequestParam parses queryparams, formData body and multipart parts
    // @RequestBody on the other hand can be used for application/json. But doesn't work for formData.

    @PutMapping(value = "/groceries/{id}", consumes = "application/json")
    public @ResponseBody Grocery editGroceryJSON(@PathVariable Integer id, @RequestBody Grocery newGrocery) {

        Grocery grocery = groceryRepository.findById(id).orElse(null);

        grocery.setItemName(newGrocery.getItemName());
        grocery.setAmount(newGrocery.getAmount());
        groceryRepository.save(grocery);
        return grocery;
    }

    // but, found out that can actually write both! using @PutMapping(value="", consumes="")

    @PutMapping(value = "/groceries/{id}", consumes = "multipart/form-data")
    public @ResponseBody Grocery editGroceryForm(@PathVariable Integer id, @RequestParam String itemName, @RequestParam Integer amount) {

        Grocery grocery = groceryRepository.findById(id).orElse(null);

        grocery.setItemName(itemName);
        grocery.setAmount(amount);
        groceryRepository.save(grocery);
        return grocery;
    }

    @DeleteMapping("/groceries/{id}")
    public @ResponseBody void deleteGrocery(@PathVariable Integer id) {
        System.out.println("Deleting: " + id);
        groceryRepository.deleteById(id);
    }

}
